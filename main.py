import os  # Importing the os module for environment variables
import openai  # Importing the openai library
from langchain.llms import OpenAI  # Importing the custom language model library
from selenium import webdriver  # Importing the selenium library for web scraping
from selenium.webdriver.common.keys import Keys  # Importing Keys for keyboard input
from selenium.webdriver.support import expected_conditions as EC  # Importing expected_conditions for waiting
from selenium.webdriver.common.by import By  # Importing By for locating elements
from selenium.webdriver.support.wait import WebDriverWait  # Importing WebDriverWait for waiting for elements
import streamlit as st  # Importing streamlit for building the web app
from dotenv import load_dotenv  # Importing dotenv for loading environment variables
from streamlit_extras.add_vertical_space import add_vertical_space  # Importing a custom Streamlit component
import time  # Importing time for delays and time handling

load_dotenv()  # Loading environment variables from .env file

with st.sidebar:
    st.title('ðŸ¤—ðŸ’¬ Linkedin Automation App')
    st.markdown('''
    ## About
    This app is a Selenium Powered Web Scraper built using:
    - [Streamlit](https://streamlit.io/)
    - [Selenium](https://www.selenium.dev/)
    - [Linkedin](https://linkedin.com)
    ''')
    add_vertical_space(5)
    service = st.selectbox("Services: ", ["Home", "Add Connections", "Send Custom Message to connections",
                                          "Send Message generated by AI"])  # Selecting a service from the sidebar


def generate_msg(prompt, count=1):
    """
    Generates an AI-generated message based on the given prompt.

    Args:
        prompt (str): The prompt describing the message to generate.
        count (int): The count of message generation attempts.

    Returns:
        str or None: The generated message if successful, None otherwise.
    """
    llm = OpenAI(temperature=0.9)  # Initializing the OpenAI language model
    generated_msg = llm.predict(prompt)  # Generating the message using the language model
    st.write(generated_msg)  # Displaying the generated message
    choice = st.selectbox(f"{count}. Do you want to change the message",
                          ["Choose", "Yes", "No"])  # Selecting an option for changing the message
    if choice == "Choose":
        pass  # Placeholder, no action needed
    elif choice == "Yes":
        rerun = st.selectbox(f"{count}. Do you want to generate the message again",
                             ["Choose", "Yes", "No"])  # Selecting an option for regenerating the message
        if rerun == "Choose":
            pass  # Placeholder, no action needed
        elif rerun == "Yes":
            new_prompt = st.text_input(
                f"{count}. Enter a new prompt describing the message you want to generate")  # Input field for entering a new prompt
            count += 1  # Incrementing the attempt count
            if new_prompt:
                generate_msg(prompt=new_prompt,
                             count=count)  # Recursive call to generate a new message
        else:
            st.subheader("To edit the above message:")
            edited_msg = st.text_area(
                "Please paste the above generated message here and make your changes")  # Text area for editing the generated message
            if edited_msg:
                return edited_msg  # Returning the edited message
    else:
        return generated_msg  # Returning the generated message


def cust_msg(msg, name):
    """
    Adds a personalized greeting to the message with a given name.

    Args:
        msg (str): The message to be customized.
        name (str): The name to include in the personalized greeting.

    Returns:
        str: The customized message with the personalized greeting.
    """
    msg = f"""Hi {name},

    {msg}"""
    return msg


def add_connection(url, no_pages):
    """
    Sends connection requests to LinkedIn profiles based on a given URL.

    Args:
        url (str): The URL of the first page from which to send connection requests.
        no_pages (int): The number of pages to iterate.

    Returns:
        None
    """
    driver = start_chrome()  # Starting the Chrome driver
    for i in range(1, no_pages + 1):
        driver.get(f"{url}&page={i}")  # Opening the LinkedIn URL with page number
        time.sleep(2)  # Delay for page load

        all_buttons = driver.find_elements(By.TAG_NAME, "button")  # Finding all buttons on the page
        connect_buttons = [btn for btn in all_buttons if btn.text == "Connect"]  # Selecting the "Connect" buttons

        if len(connect_buttons) == 0:  # If no "Connect" buttons found
            buttons = [btn for btn in all_buttons if
                       btn.text == "Message" or btn.text == "Pending" or btn.text == "Follow"]  # Finding other buttons like "Message", "Pending", "Follow"
            if len(buttons) == 0:  # If no buttons found, breaking the loop
                break
            continue

        for btn in connect_buttons:
            driver.execute_script("arguments[0].click();", btn)  # Clicking the "Connect" button
            time.sleep(2)  # Delay for modal to load

            send_button = driver.find_element(By.XPATH,
                                              "//button[@aria-label='Send now']")  # Finding the "Send now" button
            driver.execute_script("arguments[0].click();", send_button)  # Clicking the "Send now" button
            try:
                close = driver.find_element(By.XPATH, "//button[@aria-label='Dismiss']")  # Finding the "Dismiss" button
                driver.execute_script("arguments[0].click();", close)  # Clicking the "Dismiss" button
            except:
                pass
            time.sleep(2)  # Delay for action completion


def send_msg(msg, url, no_pages, add_name):
    """
    Sends a custom message to LinkedIn connections based on a given message, URL, and number of pages.

    Args:
        msg (str): The custom message to send.
        url (str): The URL of the first page from which to send the message.
        no_pages (int): The number of pages to iterate.
        add_name (bool): Whether to include the name of the connection in the message.

    Returns:
        None
    """
    driver = start_chrome()  # Starting the Chrome driver
    for a in range(1, no_pages + 1):

        driver.get(f"{url}&page={a}")  # Opening the LinkedIn URL with page number
        time.sleep(2)  # Delay for page load

        all_buttons = driver.find_elements(By.TAG_NAME, "button")  # Finding all buttons on the page
        message_button = [btn for btn in all_buttons if btn.text == "Message"]  # Selecting the "Message" buttons

        if len(message_button) == 0:  # If no "Message" buttons found
            break  # Breaking the loop

        for i in range(len(message_button)):

            driver.execute_script("arguments[0].click();", message_button[i])  # Clicking the "Message" button
            time.sleep(2)  # Delay for modal to load

            main_div = driver.find_element(By.XPATH,
                                           "//div[starts-with(@class, 'msg-form__msg-content-container')]")  # Finding the main message container
            driver.execute_script("arguments[0].click();", main_div)  # Clicking the main message container

            all_span = driver.find_elements(By.TAG_NAME, "span")  # Finding all span elements
            all_span = [s for s in all_span if
                        s.get_attribute("dir") == "ltr"]  # Selecting span elements with ltr attribute

            all_names = []

            for j in all_span:
                name = j.text.split("View")[0].split()[0]  # Extracting the name from the span text
                all_names.append(name.title())  # Appending the title-cased name to the list

            if add_name:
                msg = cust_msg(msg, all_names[i])  # Customizing the message with the connection's name
            paragraphs = driver.find_elements(By.TAG_NAME, "p")  # Finding all paragraph elements
            paragraphs[-5].send_keys(msg)  # Sending the customized message to the message input field

            submit = driver.find_element(By.XPATH, "//button[@type='submit']").click()  # Clicking the submit button
            time.sleep(2)  # Delay for action completion

            buttons_msg_box = driver.find_elements(By.TAG_NAME, "button")  # Finding all buttons in the message box
            class_name = 'msg-overlay-bubble-header__control artdeco-button artdeco-button--circle artdeco-button--muted artdeco-button--1 artdeco-button--tertiary ember-view'.split()  # Expected class name for the close button
            close_button = [btn for btn in buttons_msg_box if class_name == btn.get_attribute("class").split()][
                0]  # Selecting the close button
            driver.execute_script("arguments[0].click();", close_button)  # Clicking the close button
            time.sleep(2)  # Delay for action completion


def start_chrome():
    """
    Initializes and starts the Chrome webdriver for Selenium automation.

    Returns:
        webdriver.Chrome: The Chrome webdriver instance.
    """
    while True:

        driver = webdriver.Chrome()  # Creating an instance of the Chrome webdriver
        driver.get("https://linkedin.com")  # Opening the LinkedIn website
        time.sleep(2)  # Delay for page load

        try:
            username = driver.find_element(By.XPATH, "//input[@name='session_key']")  # Finding the username input field
            break  # Breaking the loop if the username input field is found
        except:
            driver.close()
            continue

    password = driver.find_element(By.XPATH, "//input[@name='session_password']")  # Finding the password input field

    username.send_keys(os.environ.get("Linkendin_Email"))  # Entering the username
    password.send_keys(os.environ.get("Linkendin_Password"))  # Entering the password

    time.sleep(2)  # Delay for action completion

    submit = driver.find_element(By.XPATH, "//button[@type='submit']")  # Finding the submit button
    driver.execute_script("arguments[0].click();", submit)  # Clicking the submit button
    time.sleep(2)  # Delay for action completion

    return driver  # Returning the Chrome webdriver instance


def main():
    """
    The main function of the LinkedIn Automation App.

    Returns:
        None
    """
    if service == "Add Connections":
        url = st.text_input(
            "Enter URL of the first page from which you want to send connection requests")  # Input field for URL
        if url:
            no_pages = st.number_input(
                "Enter the number of pages you want to iterate")  # Number input for number of pages
            if no_pages:
                add_connection(url=url, no_pages=int(no_pages))  # Calling the add_connection function

    elif service == "Send Custom Message to connections":
        msg = st.text_area("Enter the message you want to send")  # Text area for the custom message
        if msg:
            add_name = st.selectbox("Do you want to Add the name of the connection to the message",
                                    ["Yes", "No"])  # Selecting whether to include name
            if add_name:
                url = st.text_input(
                    "Enter URL of the first page from which you want to send the message")  # Input field for URL
                if url:
                    no_pages = st.number_input(
                        "Enter the number of pages you want to iterate")  # Number input for number of pages
                    if no_pages:
                        add_name = True if add_name == "Yes" else False  # Converting selection to boolean
                        send_msg(url=url, no_pages=int(no_pages), add_name=add_name,
                                 msg=msg)  # Calling the send_msg function

    elif service == "Send Message generated by AI":
        api_key = st.text_input("Enter your OpenAI API key")  # Input field for OpenAI API key
        if api_key:
            prompt = st.text_input(
                "Enter a prompt describing the message you want to generate")  # Input field for prompt
            if prompt:
                msg = generate_msg(prompt=prompt)  # Calling the generate_msg function
                if msg:
                    add_name = st.selectbox("Do you want to Add the name of the connection to the message",
                                            ["Yes", "No"])  # Selecting whether to include name
                    if add_name:
                        url = st.text_input(
                            "Enter URL of the first page from which you want to send the message")  # Input field for URL
                        if url:
                            no_pages = st.number_input(
                                "Enter the number of pages you want to iterate")  # Number input for number of pages
                            if no_pages:
                                add_name = True if add_name == "Yes" else False  # Converting selection to boolean
                                send_msg(msg=msg, url=url, no_pages=int(no_pages),
                                         add_name=add_name)  # Calling the send_msg function

    elif service == "Home":
        st.title('ðŸ¤—ðŸ’¬ Linkedin Automation App')
        st.write("Welcome to the LinkedIn Automation App :)")  # Displaying a welcome message
        st.write("These are the services we provide:")
        st.write("- Add Connections")
        st.write("- Send Message to connections")
        st.write("- Send Message generated by AI")
        st.write("To use these services, please take a look at the sidebar and select the desired service")
        st.subheader("Thank You")  # Displaying a thank you message


if __name__ == "__main__":
    main()
